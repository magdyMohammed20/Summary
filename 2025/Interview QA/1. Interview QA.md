(1) Let VS Var VS Const
-------------------------

==> var   : Non Blocked Scoped (Function Scope)   - Can ReAssign And Redeclare         - Hoisted (undefined)
==> let   : Has Function Scope And Block Scope    - Can ReAssign But Not Redeclared    - Hoisted (No Initialization)
==> const : Has Function Scope And Block Scope    - Can't ReAssign And Not Redeclared  - Hoisted (No Initialization)


(2) anonymous function
---------------------------
==> a function that does not have a name. 
==> usually created for specific tasks and are often assigned to variables or used as arguments for other functions (SetTimeout - map - IIFE - Arrow Functions - )


(3) Closure
---------------
==> دالة داخلية تحتفظ بمتغيرات الدالة الخارجية حتى بعد انتهاء تنفيذها

        function outerFunction() {
            let count = 0; // متغير داخل الدالة الخارجية
            
            function innerFunction() {
                count++; // تستطيع الوصول إلى count حتى بعد انتهاء outerFunction
                console.log(count);
            }
            
            return innerFunction;
        }

        const counter = outerFunction(); // استدعاء الدالة الخارجية

        counter(); // 1
        counter(); // 2
        counter(); // 3

(20) Closure
----------------
==> If I Have Inner Method That Need To Access Property From Outer Method So The Property Will Be Consider As Closure For The Inner Method
    And Will Be Set In 'Scopes' And Inside 'Closure' 


    const privateCounter = () => {
        let count = 0;
        let x = 10; ////////// This Will Not Consider In The Closure As It Not Used Inside The Return /////////////
        return {
            getValue(){
                return count;
            },
            incrementValue(val = 1){
                count += val
            }
        }
    }

    const counter = privateCounter()

    console.log(counter.getValue) // Here Will See The 'Scopes' And 'Closure' Values



(4) Strict Mode
------------------
==> A mode in JavaScript used to enforce stricter rules when writing code, which helps detect potential errors and prevent some unwanted behaviors.
==> Prevent the use of undefined variables
==> Prevent deletion of variables or functions
==> Prevent assigning a value to non-writable objects
==> Prevent the use of reserved words

EX
---

    "use strict";

    x = 10; // ❌ خطأ: x لم يتم تعريفه باستخدام let أو var أو const
    console.log(x);

(5) ReactJs Life Cycle
------------------------
==> Mounting : component is being inserted into the DOM
==> Update : occurs whenever a component's state or props change
==> unMounting : occurs when a component is being removed from the DOM.


(6) Redux VS Context API
------------------------

==> Context API
-----------------
--> You have a small to medium-sized application with relatively simple state management needs.
--> You want to avoid prop drilling within a specific part of your application.
--> You prefer a simpler setup and don't need advanced features like middleware or time-travel debugging.

==> Redux
-----------------
--> You have a larger application with complex state management requirements.
--> You need to manage global state that is accessed and updated by various parts of your application.
--> You require advanced features like middleware for handling asynchronous operations or need the flexibility of time-travel debugging.


(7) Different Between filter and find
-----------------------------------------

==> filter
------------
--> The filter method creates a new array containing all the elements of the original array that pass a given condition.
--> It iterates over each element of the array and executes a callback function for each element.
--> The callback function should return a boolean value (true or false) to determine whether an element should be included in the resulting array.
--> If no elements satisfy the condition, an empty array will be returned.
--> The filter method does not modify the original array.

==> find
------------
--> The find method returns the first element in the array that satisfies the given condition.
--> It iterates over each element of the array and executes a callback function for each element.
--> The callback function should return a boolean value.
--> If no element satisfies the condition, undefined will be returned.
--> The find method does not modify the original array.


(8) Different between call and bind and apply
---------------------------------------
==> call : Used To Call Function That Inside Object And Update Other Prop In Other Object

    // Call : Case1
    const ch1 = {
        name: "magdy",
        health: 60,
        fullHealth() {
            return this.health = 100
        }
    }

    // Here 'this' Refer To The Global Object ('window' In The Browser) Or ('Undefined' In Strict Mode)
    ch1.fullHealth.call()
    console.log(ch1.health) // 60

    // Here 'this' Refer To 'ch1'
    ch1.fullHealth()
    console.log(ch1.health) // 100

    // Call : Case2
    const ch1 = {
        name: "magdy",
        health: 60,
        fullHealth(num1 , num2) {
            return this.health = num1 + num2
        }
    }

    const ch2 = {
        name: "mohammed",
        health: 30
    }

    // Here We Access 'fullHealth' Function And Call It With Context Of 'ch2' Object
    ch1.fullHealth.call(ch2 , 40 , 70)
    console.log(ch2.health) // 110


==> apply : Like Call But Arguments Passed In Array

    const ch1 = {
        name: "magdy",
        health: 60,
        fullHealth(num1 , num2) {
            return this.health = num1 + num2
        }
    }

    const ch2 = {
        name: "mohammed",
        health: 30
    }

    // Passed Array Here
    ch1.fullHealth.apply(ch2 , [40 , 70])
    console.log(ch2.health) // 110


==> bind : Like (Call) But Return Output In a New Function
 
    const ch1 = {
        name: "magdy",
        health: 60,
        fullHealth(num1 , num2) {
            return this.health = num1 + num2
        }
    }

    const ch2 = {
        name: "mohammed",
        health: 30
    }

    const bindFunc = ch1.fullHealth.bind(ch2 , 40 , 70)
    console.log(bindFunc()) // 110


(9) React.memo() VS useMemo() VS useCallback()
--------------------------------------------------
==> React.memo()
----------------
--> higher-order component (HOC) used to Prevents unnecessary re-renders of components


==> useMemo()
--------------
--> built-in React hook That Memoizes expensive calculations that accepts 2 arguments — a function that computes a result and the depedencies array


==> useCallback 
---------------
--> Hook can be used to Memoizes functions to prevent unnecessary recreations


(10) cohersion
------------------
==>  Automatic Type Conversion in JavaScript When Performing Operations Between Data Types

==> Types
----------
--> Implicit Coercion : When JavaScript converts automatically.
--> Explicit Coercion : When we convert manually using functions like Number(), String(), Boolean().

(11) HOC ✅
-------------------
==> advanced method of reusing the component functionality logic. It simply takes the original component and returns the enhanced component


(12) Event Loop
--------------------
==> Which Controls In Code Execution 
(CallStack - Web API - Callback Queue (Task Queue / Macro-task queue) - Microtask Queue)
==> Any Sync Code That Don't Take Time To Execute Will Be Moved To Call Stack And Executed Directly
==> Any Async Code (setTimeOut) Will Moved To 'web API' And After The Time Ends Will Moved To 'Task Queue' 
==> Any Async Code (fetch().then()) Will Moved To 'web API' Then Microtask Queue So fetch callbacks run earlier than timeout callbacks.
==> Event callbacks (like click) are placed in the task queue when the event happens and executed only when the call stack is empty.
==> Event Loop Always Check Call Stack If CallStack Empty Will processes ALL 'Microtasks' first Then takes the next Task Queue item


(13) Event Bubbling
---------------------
==> is a mechanism where an event triggered on a child element propagates upward through its ancestors in the DOM. It allows parent elements to respond to events triggered by their child elements


(14) Event capturing
---------------------
==> occurs when a nested element gets clicked. The click event of its parent elements must be triggered before the click of the nested element. This phase trickles down from the top of the DOM tree to the target element.

(15) Psueudo Element VS Psueudo Class
---------------------------------------
==> are selectors that allow the styling of specific states or parts of elements
==> Psueudo Element : target states like ': hover' or ': active', while pseudo-elements like ' ::before ' or:: after' style specific parts of an element
==> Psueudo Element : begins with (' :: ') double colon.


==> Pseudo-Classes : selects the element and changes the state of the element based on the user interaction. For Example, Changing the color of the element when the user over it or when the user visits the link.
==> Pseudo-Classes : Pseduo Classes starts with (' : ') name



(16) Promises
----------------
==> JavaScript object that represents an asynchronous operation like API calls, file loading, or time delays easier. Think of a Promise as a placeholder for a value that will be available in the future. It can be in one of three states

    - Pending: The task is in the initial state.
    - Fulfilled: The task was completed successfully, and the result is available.
    - Rejected: The task failed, and an error is provided.


(17) Diff Between (await and then)
--------------------------------------
==> then() :  method available on Promises. It allows handling the result of a Promise once it resolves.
==> then() :  The fetch function returns a Promise ==> The first .then() converts the response into JSON ==> The second .then() logs the data ==> If an error occurs, .catch() handles it
==> Readability : Can become nested and hard to read
==> Error Handling : Uses .catch()
==> Execution Flow : Does not pause execution
==> Where to Use : Can be used anywhere
==> Best for : Multiple Promises and callbacks


==> await : is a keyword that pauses execution inside an async function until a Promise is resolved
==> await : waits until the fetch request completes 
==> Readability : Cleaner and easier to understand
==> Error Handling : Uses try...catch
==> Execution Flow : Pauses execution until the Promise resolves
==> Where to Use : Must be inside an async function
==> Best for : Sequential operations that depend on each other

(18) Callback Hell
----------------------
==> is a situation in JavaScript where you have many nested callbacks inside each other, usually caused by asynchronous code that depends on previous async results


(19) Diff Between bind & apply & call
----------------------------------------

    let obj = { num: 10 };

    ////////////////// Call /////////////////////////
    // call : invokes a function with a specified context. In other words, you can tie a function into an object as if it belonged to the object.
    function add(a) {
        return this.num + a
    }
    console.log(add.call(obj, 20)) // 30


    // call: can accept Multi params
    function addMulti(a, b) {
        return this.num + a + b;
    }
    console.log(addMulti.call(obj, 10, 50)) // 70


    ///////////////// Apply /////////////////////
    // apply : does the exact same as call(). The difference is that call() accepts an argument list, but apply() accepts an array of arguments.
    function addApply(a) {
        return this.num + a
    }
    console.log(addApply.apply(obj, [5])) // 15

    // Apply Add Multi
    function addMultiApply(a , b , c) {
        return this.num + a + b + c
    }
    console.log(addMultiApply.apply(obj, [5, 10, 40])) // 65



    ////////////////// Bind ///////////////////////////////////
    // Bind : The bind() method is reminiscent of call() and apply(). But instead of executing a function immediately, bind() returns a function that can be executed later on.

    function addBind(a) {
        return this.num + a
    }

    let funcBind = addBind.bind(obj, 20);

    console.log(funcBind()) // 30




(21) Promises vs async...await
--------------------------------

==> Promises
--------------
--> involves chaining .then and .catch methods, which can make the code look complicated and hard to read. 
--> Error handling is done using the .catch method


==> async...await
------------------
--> uses a simpler syntax that looks more like synchronous code.
--> Error handling is done using a try-catch block


(22) Explain Memoization in JS with example 
---------------------------------------------
==> Optimization Technique To Increase Function Performance By Caching Previous Results

    function memoizeAdd() {
    const cache = {};

    return function memoizedAdd(a, b) {
        const key = `${a},${b}`;

        if (key in cache) {
            return cache[key];
            } else {
            const result = a + b;

            cache[key] = result;

            return result;
            }
        };
    }

    const memoizedAdd = memoizeAdd();

    console.log(memoizedAdd(3, 4));  // Computes and caches the result.
    console.log(memoizedAdd(3, 4));  // Retrieves the result from cache.
    console.log(memoizedAdd(5, 6));  // Computes and caches a new result.
    console.log(memoizedAdd(3, 4));  // Still retrieves the result from cache.


(23) What is the Temporal Dead Zone?
----------------------------------------
==> The Scope Or Place That Not Allowed To Use Variable/Function In It

    console.log(x) // From This Line Here To The Defination Of x Is TDZ For 'x'
    sayHellow()  // From This Line Here To The Defination Of sayHellow Is TDZ For 'sayHellow'

    let x = 10

    let sayHellow = () => {
        console.log('Hellow')
    }


(24) What is Hydration in Next.js?
----------------------------------
==> is the process of transforming pre-rendered server-side content into an interactive user interface on the client side


(25) OOP Concepts
-------------------
==> Encapsulation : means bundling data (properties) and functions (methods) inside a class, and restricting direct access to some parts.
==> Inheritance   : allows one class to acquire the properties and methods of another class.
==> Polymorphism  : means one method name can perform different actions depending on the object.
==> Abstraction   : hides unnecessary details and exposes only the important parts.


(26) Overloading vs Overriding
---------------------------------
==> Overloading : Function overloading is the ability to create multiple functions with the same name but different parameters
                  (JavaScript does not natively support function overloading)
                  
==> Overriding  : occurs when a subclass or child class provides the specific implementation for the method that is
                  already defined in its superclass or parent class


(27) Event Delegation
-----------------------
==> a pattern to handle events efficiently. Instead of adding an event listener to each and every similar element, we can add an event listener to a parent element and call an event on a particular target using the .target property of the event object


    <ul class="courses">
      <li class="course-item">Html</li>
      <li class="course-item">Css</li>
      <li class="course-item">Js</li>
    </ul>

    const coursesParent = document.querySelector('.courses')

    coursesParent.addEventListener('click' , e => {

        if(e.target && e.target.classList.contains('course-item')){
            console.log(e.target.innerText)
        }

    })

(28) Scopes in JavaScript
----------------------------
==> Global Scope  : A global variable refers to a variable that is declared outside any function or block, so it can be used anywhere in the program
==> Local Scope   : A local variable is a variable declared inside a function, making it accessible only within that function. It cannot be used outside the function.
==> Block Scope   : refers to variables declared with let or const inside a { } block. These variables are accessible only within that block and not outside it
==> Lexical Scope : The variable is declared inside the function and can only be accessed inside that block or nested block is called lexical scope.
==> Modular Scope : Introduced in ES6, ES Modules are the standard way to organize JavaScript code into reusable and maintainable chunks. Each module has its own scope, and anything declared within a module is private by default unless explicitly exported.


(29) Arrow Function vs. Regular Function
----------------------------------------

==> Arrow Function
-----------------------
--> Can Return Value Directly After Arrow Of The Function
--> When Use 'this' Keyword It Will Refer To The Execution Context
--> Use 'Rest Parameter' To Access The Arguments

==> Regular Function
----------------------
--> Must Use Return Keyword For Return Value
--> When Use 'this' Keyword It Will Refer To The Owner Object Of The Function
--> Use 'arguments' Key Word To Access The Arguments


(30) CSS Specificity
------------------------
==> algorithm that determines which style declaration is applied to an element.

--> Inline styles                                                                 : Highest priority
--> Id selectors                                                                  : Second highest priority
--> Classes, attribute selectors and pseudo-classes (test, [type="text"], :hover) : Third highest priority
--> Elements and pseudo-elements ( h1, ::before, ::after )                        : Low priority
--> Universal selector and :where() (*, where())                                  : No priority 


(31) Performance Optimization in ReactJs
------------------------------------------
==> Use React.Fragments to Avoid Additional HTML Element Wrappers
==> Avoid Inline Function Definition in the Render Function.
==> Throttling and Debouncing Event Action in JavaScript
==> Memoize React Components
==> Analyzing and Optimizing Your Webpack Bundle Bloat
==> Lazy loading Images in React 
==> Code Splitting 


(32) Code Splitting 
---------------------------
==> Technique Used To Minmize The Bundle Size Of Generated Script After Build 
==> Make It Using 'lazy loaded components'

(33) useCallback vs. useMemo 
-------------------------------
==> useMemo : will remember the returned value from your function.
==> useCallback will remember your actual function.


(34) Controlled vs. uncontrolled component in ReactJs
------------------------------------------------------
==> A controlled component in React is an element whose state is controlled by React itself. This means that the component's state is stored in a React component's state and can only be updated by triggering a state change via React’s setState() method.

==> An uncontrolled component in React refers to a component where the form element's state is not directly controlled by React. Instead, the form element itself maintains its own state, and React only interacts with the element indirectly through references (refs).


(35) Why do we need keys in React?
------------------------------------
==> Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:


(36) why we couldn't use class in React instead of className
------------------------------------------------------------------
==> is that the class is a reserved keyword in JavaScript and since we use JSX in React which itself is the extension of JavaScript, so we have to use className instead of class attribute. Also, when the JSX is transpiled to JavaScript if we are using a class attribute it will conflict with the JavaScript classes. That's why to achieve better compatibility and consistency with other libraries React use className instead of the class attribute.

(37) localStorage vs. sessionStorage vs. cookies
--------------------------------------------------
==> LocalStorage

    Pros:

    Web storage can be viewed simplistically as an improvement on cookies, providing much greater storage capacity. If you look at the Mozilla source code we can see that 5120KB (5MB which equals 2.5 Million chars on Chrome) is the default storage size for an entire domain. This gives you considerably more space to work with than a typical 4KB cookie.
    The data is not sent back to the server for every HTTP request (HTML, images, JavaScript, CSS, etc) - reducing the amount of traffic between client and server.
    The data stored in localStorage persists until explicitly deleted. Changes made are saved and available for all current and future visits to the site.


    Cons:

    It works on same-origin policy. So, data stored will only be available on the same origin.


==> Cookies
--------------

    Pros:

    Compared to others, there's nothing AFAIK.


    Cons:

    The 4K limit is for the entire cookie, including name, value, expiry date etc. To support most browsers, keep the name under 4000 bytes, and the overall cookie size under 4093 bytes.
    The data is sent back to the server for every HTTP request (HTML, images, JavaScript, CSS, etc) - increasing the amount of traffic between client and server.
    Typically, the following are allowed:

    300 cookies in total
    4096 bytes per cookie
    20 cookies per domain
    81920 bytes per domain(Given 20 cookies of max size 4096 = 81920 bytes.)



==> sessionStorage
---------------------

    Pros:

    It is similar to localStorage.
    The data is not persistent i.e. data is only available per window (or tab in browsers like Chrome and Firefox). Data is only available during the page session. Changes made are saved and available for the current page, as well as future visits to the site on the same tab/window. Once the tab/window is closed, the data is deleted.


    Cons:

    The data is available only inside the window/tab in which it was set.
    Like localStorage, it works on same-origin policy. So, data stored will only be available on the same origin.


(38) What is the different between useReducer and useState?
-----------------------------------------------------------------

==> useReducer
-----------------
--> When State Type Is (Object , Array)
--> When Number Of State Update Is Too Many
--> When Data Of The State Related To Each Other

==> useState
-----------------
--> When State Type Is (Number,String,Boolean)
--> When Number Of State Update Is Low
--> When Data Of The State Not Related To Each Other


(39) CSS Modules
-----------------
==> feature let you use the same CSS class name in different files without worrying about naming clashes
==> Handle It By Naming File Like 'style.module.css'

    style.module.css
    --------------------

    .red{
        ...
    }


    App.jsx
    ---------

    import styles from './style.module.css'
    
    <div className={styles.red}></div>

==> Can 'Compose' Classes To Handle Reuse Css Styles In Css Modules

    .red{
        color: red
    }

    .blue{
        color: blue
    }

    .bold{
        font-weight: bold
    }

    .parent{
        compose: red bold
    }

    .child{
        compose: blue bold
    }

(40) Middleware in NextJs
---------------------------
==> Route Handler That Make Handle For Request And Response

==> Sample Of Usage : Check The Client Side Request If Not Have Token It Returns Error To The Client Without Reach To The Server

==> Benefits : Is mediator Between Client And Server Which Can Check The Request From Client Side Before Arrive To The Server So It Minmize The Traffic On The Server

(41) UseEffect Can Be Async 
-----------------------------
==> No — useEffect itself cannot be async, but you can use async code inside it.
==> React expects useEffect to return either nothing, or a cleanup function
    But an async function always returns a Promise, which React does NOT accept as a cleanup function


(42) How To Enhance This
--------------------------

import React, { useState, useEffect } from 'react';
 
const UserList = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');
 
  useEffect(() => {
    fetchUsers();
  });
 
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('https://jsonplaceholder.typicode.com/users');
      const userData = await response.json();
      setUsers(userData);
    } finally {
      setLoading(false);
    }
  };
 
  const filteredUsers = users.filter(user => 
    user.name.toLowerCase().includes(filter.toLowerCase()) ||
    user.email.toLowerCase().includes(filter.toLowerCase())
  );
 
  const deleteUser = (userId) => {
    const updatedUsers = users;
    const userIndex = updatedUsers.findIndex(user => user.id === userId);
    if (userIndex > -1) {
      updatedUsers.splice(userIndex, 1);
      setUsers(updatedUsers);
    }
  };
 
  const renderUsers = () => {
    return filteredUsers.map(user => (
  <div className="user-card">
  <h3>{user.name}</h3>
  <p>{user.email}</p>
  <button onClick={() => deleteUser(user.id)}>Delete</button>
  </div>
    ));
  };
 
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Checking for updates...');
      // Some periodic task
    }, 5000);
  }, []);
 
  if (loading) {
    return <div>Loading...</div>;
  }
 
  return (
<div className="user-list-container">
<h2>User Directory</h2>
<input
        type="text"
        placeholder="Search users..."
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        className="search-input"
      />
<div className="users-grid">
        {renderUsers()}
</div>
</div>
  );
};
 
export default UserList;


(43) Deep Copy, Shallow Copy
-------------------------------

==> Shallow Copy : Occurs Only On Objects And Arrays 
-----------------

    
    ////////////////// First Shallow Copy Shape ////////////////////
    const a1 = [10, 20, 30]

    console.log(a1)

    a2 = a1

    console.log(a2)

    a2[0] = 1000


    // Here Becomes Same As Shallow Copy
    console.log(a2) // [1000, 20, 30]
    console.log(a1) // [1000, 20, 30]


    ////////////////// Second Shallow Copy Shape  ////////////////////
    const a3 = [10, 20, 30]

    console.log(a3)

    a4 = [...a3]

    console.log(a4) // [10, 20, 30]

    a4[0] = 0

    console.log(a3) // [10, 20, 30]
    console.log(a4) // [0, 20, 30]


    ////////////////// Third Shallow Copy Shape  ////////////////////

    const pizza1 = {
        size: 'large',
        toppings: ['Cheese' , 'sausage']
    }

    const pizza2 = { ...pizza1 }

    pizza2.toppings[1] = 'Anchovies'

    console.log(pizza1) // {size: 'large', toppings: ['Cheese' , 'Anchovies'] }
    console.log(pizza2) // {size: 'large', toppings: ['Cheese' , 'Anchovies'] }



==> Deep Copy
-----------------


    ////////////////// First Deep Copy Shape (structuredClone)  ////////////////////

    const pizza1 = {
        size: 'large',
        toppings: ['Cheese' , 'sausage']
    }

    const pizza2 = structuredClone(pizza1)

    pizza2.toppings[1] = 'Anchovies'

    console.log(pizza1) // {size: 'large', toppings: ['Cheese' , 'sausage'] }
    console.log(pizza2) // {size: 'large', toppings: ['Cheese' , 'Anchovies'] }
    

    ////////////////// Second Deep Copy Shape (structuredClone)  ////////////////////

    const pizza3 = {
        size: 'large',
        toppings: ['Cheese' , 'sausage']
    }

    const pizza4 = JSON.parse(JSON.stringify(pizza2))

    pizza4.toppings[1] = 'Anchovies'

    console.log(pizza3)  // {size: 'large', toppings: ['Cheese' , 'sausage'] } 
    console.log(pizza4)  // {size: 'large', toppings: ['Cheese' , 'Anchovies'] }
   


(44) Deep Copy, Shallow Copy
-------------------------------

const original = { a: 1, b: { c: 2 } };

const copy = { ...original };

copy.b.c = 5;

console.log(original.b.c);


(45) Reverse Each Word In String
--------------------------------

	let str = 'Welcome Magdy Mohammed'

	let split = str.split('').reverse().join('')

	// demmahoM ydgaM emocleW
	console.log(split)
	
	
(46) empty an array
-------------------

    // Method 1 (set the variable arrayList to a new empty array. This is recommended if you don't have references to the original array arrayList anywhere else because It will actually create a new empty array)

    let arr1 = [1, 2, 3]
    arr1 = []
    console.log(arr1)


    // Method 2 (will clear the existing array by setting its length to 0. This way of empty the array also updates all the reference variable which points to the original array)

    let arr2 = [1, 2, 3]
    arr2.length = 0
    console.log(arr2)


    // Method 3 (This way of empty the array will also update all the references of the original array)

    let arr3 = [1, 2, 3]
    arr3.splice(0, arr3.length)
    console.log(arr3)


(47) check if a number is an integer
------------------------------------
==> see if there is a remainder left when you divide by 1

	console.log(10 % 1 === 0) // True
	console.log(10.4 % 1 === 0) // False
	console.log(10.004 % 1 === 0) // False
	
	
(48) Explain what a callback function is and provide a simple example
---------------------------------------------------------------------
==> is a function that is passed to another function as an argument and is executed after some operation has been completed

	function pushToArray(arr, callback) {
	    arr.push(1)
	    console.log(arr)

	    callback()
	}

	function callback() {
	    console.log('Pushing Is Done..')
	}
	let arr = [2, 3]

	pushToArray(arr, callback)
	

(49) What Output
----------------
==> If condition statement evaluate using eval so eval(function f() {}) which return function f() {} which is true so inside if statement code executes. typeof f return undefined because if statement code executes at run time, so statement inside if condition evaluated at run time.

	var y = 1;
	if (function f() {}) {
	  y += typeof f;
	}
	console.log(y); // 1undefined
	
	
(50) What will the following code output?
-----------------------------------------
==> The code above will output 5 even though it seems as if the variable was declared within a function and can't be accessed outside of it. This is because var a = b = 5; is interpreted the following way: var a = b; b = 5; But b is not declared anywhere in the function with var so it is set equal to 5 in the global scope

	(function() {
	  var a = b = 5;
	})();

	console.log(b); // 5
	
	
(51) What will the following code output?
-----------------------------------------
==> Output Is 4 For 4 Times

	for (var i = 0; i < 4; i++) {
	  setTimeout(() => console.log(i), 0)
	}
	
	
(52) Find Vowels In String
--------------------------

	function vowels(str) {

	    let vowels = ['a', 'e', 'i', 'o', 'u'],
		count = 0

	    for (let char of str.toLowerCase()) {
		vowels.includes(char) ? count++ : count
	    }

	    return count
	}


	console.log(vowels('Magdy')) // 1

	console.log(vowels('Magdy Mohammed ai')) // 6
	

() SOLID Priciples
----------------------
==